"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePrunnedHash = exports.hashExternalNodes = exports.mapExternalNodes = exports.getNodeName = exports.isRootVersion = exports.hashString = exports.sortObject = void 0;
const hashing_impl_1 = require("../hasher/hashing-impl");
const workspace_root_1 = require("../utils/workspace-root");
const fs_1 = require("fs");
/**
 * Simple sort function to ensure keys are ordered alphabetically
 * @param obj
 * @returns
 */
function sortObject(obj, valueTransformator = (value) => value, descending = false, sortFunction) {
    const keys = Object.keys(obj);
    if (keys.length === 0) {
        return;
    }
    keys.sort(sortFunction);
    if (descending) {
        keys.reverse();
    }
    const result = {};
    keys.forEach((key) => {
        result[key] = valueTransformator(obj[key]);
    });
    return result;
}
exports.sortObject = sortObject;
/**
 * Apply simple hashing of the content using the default hashing implementation
 * @param fileContent
 * @returns
 */
function hashString(fileContent) {
    return hashing_impl_1.defaultHashing.hashArray([fileContent]);
}
exports.hashString = hashString;
function isRootVersion(packageName, version) {
    const fullPath = `${workspace_root_1.workspaceRoot}/node_modules/${packageName}/package.json`;
    if ((0, fs_1.existsSync)(fullPath)) {
        const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
        return JSON.parse(content).version === version;
    }
    else {
        return false;
    }
}
exports.isRootVersion = isRootVersion;
/**
 * Returns node name depending whether it's root version or nested
 */
function getNodeName(dep, version, rootVersion) {
    return rootVersion ? `npm:${dep}` : `npm:${dep}@${version}`;
}
exports.getNodeName = getNodeName;
function mapExternalNodes(lockFileData, transitiveLookupFn) {
    const result = {
        dependencies: {},
        externalNodes: {},
        nodes: {},
    };
    const versionCache = {};
    Object.entries(lockFileData.dependencies).forEach(([packageName, versions]) => {
        Object.values(versions).forEach(({ version, rootVersion, dependencies, peerDependencies }) => {
            // save external node
            const nodeName = getNodeName(packageName, version, rootVersion);
            result.externalNodes[nodeName] = {
                type: 'npm',
                name: nodeName,
                data: {
                    version,
                    packageName,
                },
            };
            const combinedDependencies = dependencies || peerDependencies
                ? Object.assign(Object.assign({}, (dependencies || {})), (peerDependencies || {})) : undefined;
            if (combinedDependencies) {
                const nodeDependencies = [];
                const transitiveDeps = mapTransitiveDependencies([packageName], lockFileData.dependencies, combinedDependencies, versionCache, transitiveLookupFn);
                transitiveDeps.forEach((target) => {
                    nodeDependencies.push({
                        type: 'static',
                        source: nodeName,
                        target,
                    });
                });
                result.dependencies[nodeName] = nodeDependencies;
            }
        });
    });
    return result;
}
exports.mapExternalNodes = mapExternalNodes;
// Finds the maching version of each dependency of the package and
// maps each {package}:{versionRange} pair to "npm:{package}@{version}" (when transitive) or "npm:{package}" (when root)
function mapTransitiveDependencies(parentPackages, packages, dependencies, versionCache, transitiveLookupFn) {
    if (!dependencies) {
        return [];
    }
    const result = [];
    Object.keys(dependencies).forEach((packageName) => {
        var _a, _b;
        const versions = packages[packageName];
        // some of the peer dependencies might not be installed,
        // we don't have them as nodes in externalNodes
        // so there's no need to map them as dependencies
        if (!versions) {
            return;
        }
        // fix for pnpm versions that might have suffixes - `1.2.3_@babel+core@4.5.6`
        const version = dependencies[packageName].split('_')[0];
        const key = `${packageName}@${version}`;
        // if we already processed this dependency, use the version from the cache
        if (versionCache[key]) {
            result.push(versionCache[key]);
        }
        else {
            const matchedVersion = versions[`${packageName}@${version}`]
                ? version
                : (_a = transitiveLookupFn({
                    packageName,
                    parentPackages,
                    versions,
                    version,
                })) === null || _a === void 0 ? void 0 : _a.version;
            // for some peer dependencies, we won't find installed version so we'll just ignore these
            if (matchedVersion) {
                const nodeName = getNodeName(packageName, matchedVersion, (_b = versions[`${packageName}@${matchedVersion}`]) === null || _b === void 0 ? void 0 : _b.rootVersion);
                result.push(nodeName);
                versionCache[key] = nodeName;
            }
        }
    });
    return result;
}
function hashExternalNodes(projectGraph) {
    Object.keys(projectGraph.externalNodes).forEach((key) => {
        if (!projectGraph.externalNodes[key].data.hash) {
            // hash it using it's dependencies
            hashExternalNode(projectGraph.externalNodes[key], projectGraph);
        }
    });
}
exports.hashExternalNodes = hashExternalNodes;
function hashExternalNode(node, graph) {
    const hashKey = `${node.data.packageName}@${node.data.version}`;
    if (!graph.dependencies[node.name]) {
        node.data.hash = hashString(hashKey);
    }
    else {
        const hashingInput = [hashKey];
        traverseExternalNodesDependencies(node.name, graph, hashingInput);
        node.data.hash = hashing_impl_1.defaultHashing.hashArray(hashingInput.sort());
    }
}
function traverseExternalNodesDependencies(projectName, graph, visited) {
    graph.dependencies[projectName].forEach((d) => {
        const target = graph.externalNodes[d.target];
        const targetKey = `${target.data.packageName}@${target.data.version}`;
        if (visited.indexOf(targetKey) === -1) {
            visited.push(targetKey);
            if (graph.dependencies[d.target]) {
                traverseExternalNodesDependencies(d.target, graph, visited);
            }
        }
    });
}
/**
 * Generate new hash based on the original hash and pruning input parameters - packages and project name
 * @param originalHash
 * @param packages
 * @param projectName
 * @returns
 */
function generatePrunnedHash(originalHash, packages, projectName) {
    const hashingInput = [originalHash, ...packages];
    if (projectName) {
        hashingInput.push(projectName);
    }
    return hashing_impl_1.defaultHashing.hashArray(hashingInput);
}
exports.generatePrunnedHash = generatePrunnedHash;
//# sourceMappingURL=utils.js.map